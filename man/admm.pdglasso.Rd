% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimation-functions.R
\name{admm.pdglasso}
\alias{admm.pdglasso}
\title{Estimate a concentration matrix under the pdColG model using (adaptive) ADMM
graphical lasso algorithm.}
\usage{
admm.pdglasso(
  S,
  lambda1 = 1,
  lambda2 = 1e-04,
  type = c("vertex", "inside.block.edge", "across.block.edge"),
  force.symm = NULL,
  X.init = NULL,
  rho1 = 1,
  rho2 = 1,
  varying.rho1 = TRUE,
  varying.rho2 = TRUE,
  max_iter = 1000,
  eps.abs = 1e-12,
  eps.rel = 1e-12,
  verbose = FALSE
)
}
\arguments{
\item{S}{A \eqn{p \times p} covariance (or correlation) matrix.}

\item{lambda1}{A non-negative scalar (or vector) penalty that encourages
sparsity in the concentration matrix. If a vector is provided, it should
match the appropriate length, i.e.}

\item{lambda2}{A non-negative scalar (or vector) penalty that encourages
equality constraints in the concentration matrix. If a vector is provided,
it should match the appropriate length, i.e.}

\item{type}{A string or vector of strings for the type of equality
constraints to be imposed; zero, one or more available options can be
selected among: * "vertex", symmetries are imposed on the diagonal entries
of the concentration matrix. * "inside.block.edge", symmetries are imposed
between elements of the LL and RR block the concentration matrix. *
"across.block.edge", symmetries are imposed between elements of the LR and
RL block the concentration matrix. Shortened forms are accepted too, i.e.
"V" or "vert" for "vertex".}

\item{force.symm}{A string or vector of strings to impose forced symmetry on
the corresponding block of the concentration matrix. Same options as
"type".}

\item{X.init}{(optional) A \eqn{p \times p} initial guess for the
concentration matrix and/or starting solution for the ADMM algorithm.}

\item{rho1}{A scalar; tuning parameter of the ADMM algorithm to be used for
the outer loop. It must be strictly positive.}

\item{rho2}{A scalar; tuning parameter of the ADMM algorithm to be used for
the inner loop. It must be strictly positive.}

\item{varying.rho1}{A boolean value; if \code{TRUE} the parameter rho1 is updated
iteratively to speed-up convergence.}

\item{varying.rho2}{A boolean value; if \code{TRUE} the parameter rho2 is updated
iteratively to speed-up convergence.}

\item{max_iter}{An integer; maximum number of iterations to be run in case
the algorithm does not converge.}

\item{eps.abs}{A scalar; the absolute precision required for the computation
of primal and dual residuals of the ADMM algorithm.}

\item{eps.rel}{A scalar; the relative precision required for the computation
of primal and dual residuals of the ADMM algorithm.}

\item{verbose}{A boolean value; if \code{TRUE} the progress (and internal
convergence of inner loop) is shown in the console while the algorithm is
running.}
}
\value{
A list, whose element are:
\itemize{
\item \code{X}, the estimated concentration matrix
under the pdglasso model; the model is identified by the values of lambda1
and lambda 2, together with the type of penalization imposed.
\item \code{acronyms}, a vector of strings for the type of penalties and forced symmetries imposed
when calling the function.
\item \code{internal.par}, a list of internal parameters
passed to the function at the call, as well as convergence information.
}
}
\description{
By providing a covariance matrix S and values for lambda_1 and lambda_2, this
function estimates a concentration matrix X under the coloured graphical
model for paired data, using the (adaptive) ADMM algorithm. The output is the
matrix and a list of internal parameters used by the function, together with
the specific call in terms of symmetries and penalties required by the user.
}
\examples{

S <- cov(toy.data)
admm.pdglasso(S)
}
